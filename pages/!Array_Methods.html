<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ARRAY</title>

  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">
  
  <!-- MD Tag -->
  <script src="../js/Markdown-Tag-main/markdown-tag-commonmark.js"></script>

  <!-- Highlight -->
  <link rel="stylesheet" href="../js/highlight/styles/atom-one-dark.min.css">
  <script src="../js/highlight/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <!-- CSS -->
  <link rel="stylesheet" href="../css/pages.css">

</head>
<body>

  <md>
[Home](/../index.html)
# ARRAY METODE

## SADRZAJ: 
+ [SECKANJA](#seckanja) | [slice](#slice) | [splice](#splice) | [pop](#pop) | [push](#push) | [shift](#shift) | [unshift](#unshift)  
+ [RAZNI ALATI](#razni-alati) | [reverse](#reverse) | [fill](#fill) | [copyWithin](#copywithin) | [sort](#sort) | [concat](#concat) | [includes](#includes)  
+ [FILTRIRANJE POMOCU CALLBACK F-JA](#filtriranje-pomocu-callback-f-ja) | [filter](#filter) | [every](#every) | [some](#some) | [find](#find) | [findIndex](#findindex) | [indexOf](#indexof) | [lastIndexOf](#lastindexof) | [flat](#flat) | [flatMap](#flatmap)  
+ [REDUCE](#reduce) | [reduceRight](#reduceright)  
+ [MAP](#map) | [forEach](#foreach)  
+ [PAKOVANJE U STRING](#pakovanje-u-string) | [toString](#tostring), [join](#join)  
+ [ARRAY PROTOTYPE](#array-prototype) | [Array()](#array) | [Array.of()](#arrayof) | [Array.from()](#arrayfrom) | [Array.isArray()](#arrayisarray) | [Array.entries()](#arrayentries) | [Array.keys()](#arraykeys)  
+ [MANJE BITNE STVARI](#manje-bitne-stvari)

## ! Paznja !
* Skoro sve metode za Array MENJAJU original, osim onih koje koriste callbackfn.  
* Array methods are always generic (srp. opšte, generalne) — they don't access any internal (ne-index) data of the array object. They only access the array elements through the length property and the indexed elements. This means that they can be called on array-like objects as well.
</md>

<pre>
<code>const arrayLike = {
  0: "a",
  1: "b",
  length: 2,
};
Array.prototype.join.call(arrayLike, ", "); // "a, b"</code>
</pre>

<md>
* (VS CODE) Ako mi trebaju tacniji podatci sta koja metoda radi> hover preko metode i pojavi se opis.

## Promenljive koje se koriste u primerima u fajlu
</md>

<pre>
<code>let abc = ["a", "b", "c", "d", "e"];
let zxc = ['z', 'x', 'c']
let one2 = [1, 2]
</code>
</pre>


<h2 id="seckanja"><b>SECKANJA</b></h2>

<md>
### UKRATKO TABELA ISPOD PRIKAZUJE STA KOJA (SEC) METODA VRACA:
|      METODA: | shift  | unshift  | splice  |  push  |  pop  |
|         ---: |  :---: | :---:    | :---:   | :---:  | :---: |
| VRACA NAZAD: |  'a'   | length   | ['x']   | length |  'z'  |

* metode koje seku na pocetku i kraju (shift i pop) vracaju ono sto su obrisali
* metode koje ubacuju na pocetku i kraju (unshift i push) vracaju novi length
* splice vraca ono sto je odsekao, ali kao [Array]

</md><h3 id="slice"><i>slice</i></h3><md>

  * slice ~ crop, isecak ( od index-a, do indexa) ---negativne vrednosti broji od kraja. NEmenja original 'abc'  

</md>
<pre>
<code>abc = ["a", "b", "c", "d", "e"]
abc.slice(1, 4) // [b,c,d]
abc             // [a,b,c,d,e] // ostao NEporomenjen

// NEGATIVNI BROJEVI
[0,1,2,3,4,5,6,7].slice(-3)     // poslednja tri // [5,6,7]
[0,1,2,3,4,5,6,7].slice(3)      // od 3. zareza spreda se pocinje // [3,4,5,6,7]
[0,1,2,3,4,5,6,7].slice(-3,7)   // [5,6]
[0,1,2,3,4,5,6,7].slice(-4,-1)  // [4,5,6]
[0,1,2,3,4,5,6,7].slice(4,-2)   // [4,5]

// PRAVLJENJE NEZAVISNE KOPIJE
let sliceed2 = abc.slice(); console.log(sliceed2); // [a,b,c,d,e]
</code>
</pre>
<md>

</md><h3 id="splice"><i>splice</i></h3><md>
  
  * splice ~ replace - MENJA original 'abc' - Pamtim, kao da se na "slice" zalepi 'p'  

</md>
<pre>
<code>abc = ["a", "b", "c", "d", "e"]
let spliced = abc.splice(2, 1, 'Q', 'W') // index_od, duzina, novi_elementi - 'splice' od 'abc' odseca 'c' i zamenjuje ga sa 'Q', 'W' i vraca novi array od odsecenog ['c']
abc // [a,b,Q,W,d,e]
</code>
</pre>
<md>  
  * Splice super sluzi za pomeranje, ubacivanje, izbacivanje elemenata u nizu 

  * Splice moze da se poredi sa editovanjem texta (selektovanje teksta, cut, kucanje/paste):
  
    - Prva dva (prametra) od .slice su kao selekcija slova 
    u tekstu (pocetak selekcije, duzina selekcije),
    - to sto smo selektovali sa prva dva (parametra) ce da
    se cut-uje tj. da se obrise i return-uje iz .splice u obliku [niza],
    - ostali parametri su ono sto se ubacuje umesto 
    selekcije teksta tj. paste-uje se ili kuca.  

#### primeri pomeranja jednog elementa u nizu
</md>
Pomeranje 4-ke u nizu  
<pre>
<code>arr = [1,2,3,4,5]
//          ┌── ← ── 4 ── ← ──┐
arr.splice(1,0,...arr.splice(3,1))
// [ 1 4 2 3 5 ]
</code>
</pre>

Premestena 3-ka na POCETAK sa UNSHIFT  
<pre>
<code>arr = [1,2,3,4,5]
arr.unshift(...arr.splice(2,1))
// [1,2,3,4,5] => [3,1,2,4,5]
</code>
</pre>

Premestena 3-ka na KRAJ sa PUSH
<pre>
<code>arr = [1,2,3,4,5]
arr.push(...arr.splice(2,1))
// [1,2,3,4,5] => [3,1,2,4,5]
</code>
</pre>

Premestena 2 i 3-ka na kraj
<pre>
<code>arr = [1,2,3,4,5]
arr.splice(3,0, ...arr.splice(1,2))
// [ 1 4 5 2 3 ]
</code>
</pre>

Izbacena 4-ka  
<pre>
<code>arr = [1,2,3,4,5]
arr.splice(-2,1) // moze -index
// [ 1 2 3 5 ]
</code>
</pre>

<md>#### primeri razmene vrednosti dva elementa  </md>

Promena mesta 2 i 4-ke  
<pre>
<code>arr = [1,2,3,4,5]
//  ┌─── ← ──2── ← ──┐┌ ← 4 ← ┐
arr[3] = arr.splice(1, 1, arr[3]) [0]
// komutativnost parametara je moguca
arr[1] = arr.splice(3,1, arr[1]) [0] // isti rezultat
</code>
</pre>




Promena mesta 2-ke i 4-ke (Ako su poznate :vrednosti)  
<pre>
<code>arr = [1,2,3,4,5]
arr.splice(1,1,4) // select 2 and overwright with 4
arr.splice(3,1,2) // select 4 and overwright with 2
// ili u jednoj liniji
// select 2, copy, overwright ▼ 2 with 4
arr.splice(3,1,...arr.splice(1,1,4))
// select 4 ▲ and overwright with paste 2
</code>
</pre>


Ubacivanje novog elementa na odredjenu poziciju (poznate :vrednosti)  
<pre>
<code>arr = [1,2,3,4,5]
arr.splice(2,0,'x') // [ 1 2 x 3 4 5 ]
</code>
</pre>

Visestruko kopiranje (ubacivanje) elementa u nizu
<pre>
<code>arr = [1,2,3]
temp = Array(3).fill(arr[1])
arr.splice(1,1,...temp)
arr // [ 1, 2, 2, 2, 3 ]
</code>
</pre>
<md>

</md><h3 id="pop"><i>pop</i></h3><md>
  
  * pop - menja original 'abc'

</md>
<pre>
<code>abc = ["a", "b", "c", "d", "e"]
let popped = abc.pop(); // e
console.log(popped, typeof popped); // e string
console.log(abc); // ['a', 'b', 'c', 'd']
</code>
</pre>
<md>


</md><h3 id="push"><i>push</i></h3><md>
  
  * push - menja original 'abc'

</md>
<pre>
<code>abc = ["a", "b", "c", "d", "e"]
let pushed = abc.push("Pu");
console.log(abc); //  [ 'a', 'b', 'c', 'd', 'e', 'Pu' ]
console.log(pushed, typeof pushed); // 6 'number' = abc.length
</code>
</pre>
<md>


</md><h3 id="shift"><i>shift</i></h3><md>

  * shift - menja original 'abc'

</md>
<pre>
  <code>abc = ["a", "b", "c", "d", "e"]
let shifted = abc.shift();
console.log(abc); //  [ 'b', 'c', 'd', 'e' ]
console.log(shifted, typeof shifted); // a string
</code>
</pre>
<md>

</md><h3 id="unshift"><i>unshift</i></h3><md>
  
  * unshift - menja original 'abc'

</md>
<pre>
<code>abc = ["a", "b", "c", "d", "e"]
let unshifted = abc.unshift("XxX", "YOY");
console.log(abc); //  [ 'XxX', 'YOY', 'a', 'b', 'c', 'd', 'e' ]
console.log(unshifted, typeof unshifted); // 7 'number' = abc.length
</code>
</pre>
<md>  
  
---------------------------------------------------------------------------------------------------------

</md><h2 id="razni-alati"><b>RAZNI ALATI</b></h2><md>

  * PAZNJA: Alati ispod menjaju original.

</md>
<pre>
<code>var q1 = [1,2,3,4];           // Svi ispod su prakticno reference za 'q1'
var q2 = q1.fill(5,0,1);      // q2 = q1 = [5,2,3,4]
var q3 = q1.sort();           // q3 = q2 = q1 = [2,3,4,5]
var q4 = q3.reverse()         // q4 = q3 = q2 = q1 = [5,4,3,2]
var q5 = q2.copyWithin(1,2,3) // q5 = q4 = q3 = q2 = q1 = [5,3,3,2]
</code>
</pre>
<md>

</md><h3 id="reverse"><i>reverse</i></h3><md>

  * reverse ~ mirror MENJA ORIGINAL!

</md>
<pre>
<code>abc = ["a", "b", "c", "d", "e"]
let reversed = abc.reverse();
console.log(abc); //  [ 'e', 'd', 'c', 'b', 'a' ]
console.log(reversed); //  [ 'e', 'd', 'c', 'b', 'a' ]
</code>
</pre>
<md>

</md><h3 id="fill"><i>fill</i></h3><md>

  * fill ~ repeat() --- cime, od...do. MENJA ORIGINAL!

</md>
<pre>
<code>console.log(abc); //  [ 'e', 'd', 'c', 'b', 'a' ]
let filled = abc.fill('A', 2, 5); console.log(filled); // ['e', 'd', 'A', 'A', 'A']
console.log(abc); // ['e', 'd', 'A', 'A', 'A']
</code>
</pre>
<md>

</md><h3 id="copywithin"><i>copyWithin</i></h3><md>

  * copyWithin --- kopiranje elemenata unutar niza
  * parametri (gde_kopirati, sta_od, sta_do) - "sta_od" standardna vrednost mu je 'abc.length'. MENJA ORIGINAL!

</md>
<pre>
<code>let copied = abc.copyWithin(0, 4, 5); console.log(copied); // [e, b, c, d, e]
</code>
</pre>
<md>

  * Ne moze da pravi nove elemente u nizu, tj. ne moze da menja .length

</md><h3 id="sort"><i>sort</i></h3><md>

  * sort - sortiranje po unikod vrednostima (sve se konvertuje u strignove pa se sortira). MENJA ORIGINAL!

</md>
<pre>
<code>let nizAZ = ['B', 2, 'a', 'c', 'b', 1, 3, 'C', 'A', '.', '!', '?',]
let sorted1 = nizAZ.sort(); console.log(nizAZ); //[!.123?ABCabc]
console.log(sorted1); // [!.123?ABCabc]
// lexikografsko sortiranje brojeva
let niz12 = [22, 2, 3, 1, 11]
let sorted2_1 = niz12.sort(); console.log(sorted2_1); // [1 11 2 22 3]
console.log(niz12); // [1 11 2 22 3]
// sortiranje po vrednosti brojeva
let sorted2_2 = niz12.sort((a, b) => b - a); console.log(sorted2_2); // [22 11 3 2 1]
console.log(niz12); // [22 11 3 2 1]
console.log([1, 2, 3, 4, 5, 6, 7, 8, 9].sort((a, b) => { return 0.5 - Math.random() })); // [4,2,1,3,9,7,5,6,8] - ali ovo je los nacin
</code>
</pre>
<md>

</md><h3 id="concat"><i>concat</i></h3><md>

  * concat - spajanje nizova. NE MENJA ORIGINAL!

</md>
<pre>
<code>abc = ["a", "b", "c"]; zxc = ['z', 'x', 'c']; one2 = [1, 2]
let concated = zxc.concat("qwe", one2, abc); console.log(concated); // [z,x,c,qwe,1,2,a,b,c]
console.log("CONCAT: ", zxc, one2, abc); // [z,x,c][1,2][a,b,c]
concated = zxc.concat(); console.log(concated); // [z,x,c] // pravljenje kopije
</code>
</pre>
<md>

</md><h3 id="includes"><i>includes</i></h3><md>
  
  * includes ~ find - provera da li zadati element postoji u nizu. Varaca Boolean.

</md>
<pre>
<code>// callback f-ja moze da ima 2 parametra: vrednost_elementa, index_pocetka_pretrage. MENJA ORIGINAL!
abc = ["a", "b", "c", "d", "e"]
let included = abc.includes('A')
console.log(included); // false
console.log(abc); // [ 'a', 'b', 'c', 'd', 'e' ]
</code>
</pre>
<md>

</md><h2 id="filtriranje-pomocu-callback-f-ja"><b>FILTRIRANJE POMOCU CALLBACK F-JA</b></h2><md>

</md><h3 id="filter"><i>filter</i></h3><md>

  * filter - Pravi novi niz filtracijom elemenata zadatog niza, po zadatoj f-ji
  * f-ja moze da ima 4 parametra: vrednost_elementa, index_elementa, pozvani_niz, thisArg (vrednost koja se koristi kao 'this' argument pri pozivanju f-je)

</md>
<pre>
<code>abc = ['YoY', 'XxX', 'A', 'A', 'A', 'YoY', 'XxX']
let filtered = abc.filter(vred_elem => vred_elem.length > 1); // ako cb f-ja bude true, prolazi filter
console.log(abc); // [ 'YoY', 'XxX', 'A', 'A', 'A', 'YoY', 'XxX' ]
console.log(filtered);// [ 'YoY', 'XxX', 'YoY', 'XxX' ]
console.log(abc.filter(ve => ve === 'A')); //[A,A,A]
console.log(abc.filter((ve, ie, niz) => { return niz[ie % 3] === 'A' })); //! [A,YoY]
// ^^^ na pitanje: da li 'YOY' ulazi u novi niz => index od 'YOY' je 5, tj. ie = 5
// a 5%3 = 2 sto znaci da ce biti [2], a element pod indexom 2 je 'A',
// cime se ispunjava uslov za ulazak u novi niz
console.log(abc.filter((x) => { return /[a-z]/.test(x) })); //! [YoY,XxX,YoY,XxX]
abc //! [YoY,XxX,A,A,A,YOY,XxX]
intersekcijaDvaNiza = abc.filter(value => ['A', 'b', 'c', 'd'].includes(value));
console.log(intersekcijaDvaNiza); //! ['A','A','A']
// Kako oznacavati prethodni/sledeci element u nizu
// filter (e, i, a) → [ a[i-1], e, a[i+1] ]
</code>
</pre>
<md>

</md><h3 id="every"><i>every</i></h3><md>
  
  * *every* - proverava da li svi elementi mogu da prodju zadatu funkciju. Ako svi prodju, vraca True; ako jedan punke, prekida se provera i vraca False.
  * f-ja moze da ima 4 parametra: vrednost_elementa, index_elementa, pozvani_niz, thisArg (vrednost koja se koristi kao 'this' argument pri pozivanju f-je)

</md>
<pre>
<code>console.log(abc.every(x => x.length > 0 && x.length <= 3)); // true
console.log(abc); //! [YoY,XxX,d,A,A,A,YoY,XxX]
</code>
</pre>
<md>

</md><h3 id="some"><i>some</i></h3><md>

  * some - proverava da li bar jedan element moze da prodje callback f-ju. Vraca boolean
  * callback f-ja moze da ima 4 parametra: vrednost_elementa, index_elementa, pozvani_niz, thisArg (vrednost koja se koristi kao 
  'this' argument pri pozivanju f-je)

</md>
<pre>
<code>const someed = [1, 2, 'qwe', 4, 5].some(ve => ve == '4'); console.log(someed); //! true
</code>
</pre>
<md>

</md><h3 id="find"><i>find</i></h3><md>

  * find - proverava sve elemente sa callback f-jom, a ako f-ja negde vrati 'true' pretraga se prekida i vraca se vrednost tog elementa.
  * callback f-ja moze da ima 4 parametra: vrednost_elementa, index_elementa, pozvani_niz, thisArg (vrednost koja se koristi kao 'this' argument pri pozivanju f-je)

</md>
<pre>
<code>console.log(abc.find(x => /[Y]/.test(x))); // YOY // sadrzi Y
console.log(abc); //! [YoY,XxX,A,A,A,YoY,XxX]
</code>
</pre>
<md>

</md><h3 id="findindex"><i>findIndex</i></h3><md>

  * findIndex - proverava sve elemente sa callback f-jom, a ako f-ja negde vrati 'true' pretraga se prekida i vraca se index tog elementa.

</md>
<pre>
<code>console.log(abc.findIndex((x => /[Y]/.test(x)))) // 5
console.log(abc); //! [YoY,XxX,A,A,A,YoY,XxX]
abc = ['YoY', 'XxX', 'A', 'A', 'A', 'YoY', 'XxX']
</code>
</pre>
<md>


</md><h3 id="indexof"><i>indexOf</i></h3><md>

  * indexOf - trazi element, a vraca INDEX OD njega. proverava da li postoji zadati element. Ako ga nadje prkida pretragu i vraca index gde ga je naisao. Ako nije nasao -1
  * Metoda moze da ima 2 parametra: vrednost_elementa, index_pocetka_pretrage

</md>
<pre>
<code>console.log(abc.indexOf('YOY')); // -1 // da sam trazio 'YoY' bilo bi 0
console.log(abc); //! [YoY,XxX,A,A,A,YoY,XxX]
</code>
</pre>
<md>

</md><h3 id="lastindexof"><i>lastIndexOf</i></h3><md>

  * lastIndexOf - isto sto i 'indexOf, ali pretraga se vrsi sa kraja
  * Metoda moze da ima 2 parametra: vrednost_elementa, index_pocetka_pretrage

</md>
<pre>
<code>abc = ['a', 'ss', 'dD', 'F', 'ss']
console.log(abc.lastIndexOf('ss', -2)); //! 1
</code>
</pre>
<md>

</md><h3 id="flat"><i>flat</i></h3><md>

  * flat - svodjenje multi-dimenzionalnih nizova
  * Metoda moze da ima 1 parametar: dubina_svodjenja. Default je 1

</md>
<pre>
<code>num = [1,[2,[3,[4,[5,[6,[7,[8]]]]]]]]
console.log(num.flat(3)); //! [1,2,3,4,[5,[6,[7,[8]]]]]
</code>
</pre>
<md>

</md><h3 id="flatmap"><i>flatMap</i></h3><md>
  
  * flatMap ~ map+flat

</md>
<pre>
<code>let arr1 = ["it's Sunny in", "", "California"];
console.log(arr1.flatMap(x => x.split(" "))); //! ["it's","Sunny","in", "", "California"]
// Stara alternativa
console.log(arr1.map(x => x.split(" "))); //! [["it's","Sunny","in"],[""],["California"]]
console.log(arr1.map(x => x.split(" ")).flat(1)); //! ["it's","Sunny","in", "", "California"]
// Primer 2
str2split = 'qwe|asd|zxc&rty|fgh|vbn^uio|jkl&nm|mn'
str2split.split('^') // [ qwe|asd|zxc&rty|fgh|vbn, uio|jkl&nm|mn ]
.flatMap(str=>str.split("&")) // [ qwe|asd|zxc, rty|fgh|vbn, uio|jkl, nm|mn ]
.flatMap(str=>str.split("|")) // [ qwe, asd, zxc, rty, fgh, vbn, uio, jkl, nm, mn ]
// Stara alternativa
str2split.split('^')
.map(str=>str.split("&"))
.flat()
.map(str=>str.split("|"))
.flat()
</code>
</pre>
<md>

## **REDUCE**

</md><h3 id="reduce"><i>reduce</i></h3><md>

  * reduce() Sta radi? Reduce() uzma dva susedna elementa niza i nesto uradi sa njima, u zavisnosti od toga sta je definisano u callback funkciji. U sledecem krugu racunanja, ono sto je bio RETURN od prethodne callback funkcije, bice prvi argument u trenutnoj funkciji (zove se akomulator ili prethodna vrednost), a za drugi argument se uzima sledeci element niza (sabirak ili trenutna vrednost).

  * Kada se prvi put startuje callback funkcija tu nema RETURN od prethodne kalkulacije, a treba da ga bude. Ona se moze dodeliti kao drugi argument od reduce() ili kao prvi element niza koji se obradjuje. Najbolja je praksa da se stavlja kao drugi argument od reduce, jer ako se ne stavi onda ce callback funkcija po defaultu uzeti [0] element niza kao pocetnu vrednost a iteracija sabiraka pocinje od [1] elementa (umesto od [0]), sto moze dati neocekivane rezultate.

  * callback f-ja koja ide u reduce moze da ima 4 parametra: akomulator, sabirak, index_sabirka, niz_koji_se_obradjuje

</md>
<pre>
<code>function sabirach(akumulator, sabirak) { return akumulator + sabirak } // callback f-ja
let reduced = niz12.reduce(sabirach); console.log(reduced); //! 39 - vidi ispod objasnjenje
// pocetna vrednost akumulatora je 22, a 1. sabirak je 11, 2. sab. je 3, pa 2, pa 1
console.log(niz12); //! [22,11,3,2,1]

let reduced100 = niz12.reduce(sabirach, 100); console.log(reduced100); //! 139
// pocetna vrednost akumulatora je 100, a 1. sabirak je 22
console.log(niz12); //! [22,11,3,2,1]

let reducedConcat = nizAZ.reduce((a, s) => { return a.concat('*' + s + '*') }, 'QWE*');
console.log(reducedConcat); //! QWE**!**.**1**2**3**?**A**B**C**a**b**c*
// da sam kao pocetnu vrednost stavio [], onda bi return bio array
console.log(nizAZ); //! [!.123?ABCabc]

// evo primera gde se najbolje vidi kako funkcionise reduce()
arr.reduce((a,s)=>{
  console.log(a, s)
  return nan
}, 100)
// Output:
// 100 1
// NaN 2
// NaN 3
// NaN 4
// NaN 5

// ovo je jedan moj primer funkcije koja komparira da li je prvi parametar jednak sa ostalim parametrima, a izmedju svake komparacije je OR. Znaci dovoljno samo jedan da je TRUE i vratice TRUE
function equalOr(x, ...vals) {
  c = [];
  vals.reduce((a, s) => {
    c.push(a == s)
    return a
  }, x)
  return c.some(e=>e==true)
}
equalOr(q, w,e,q)
</code>
</pre>
<md>

</md><h3 id="reduceright"><i>reduceRight</i></h3><md>

  * reduceRight---Isto sto i 'reduce' samo sto pocinje sa kraja

</md>
<pre>
<code>let reduceRighted = [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]].reduceRight((aku, sab) => aku.concat(sab));
console.log(reduceRighted); //! [8, 9, 6, 7, 4, 5, 2, 3, 0, 1]
</code>
</pre>
<md>

### *PRIMENA REDUCE-a:*

  * *brojanje slova*

</md>
<pre>
<code>var brojanjeSlova = "qwe qe e"
  .split("") // [q,w,e, ,q,e, ,e]
  .reduce ((rezultat, slovo)=>{
  if (slovo in rezultat) rezultat[slovo]++
  else rezultat[slovo]=1
  return rezultat
  }, {}) // bitno je koristiti {} kao pocetni objekat da bi i prvo slovo proslo kroz cb fju
console.log (brojanjeSlova) // {q:2, w:1, e:3, " ":2}
</code>
</pre>
<md>

  * *Grupisanje objekata po svojstvu "prosek"*

</md>
<pre>
<code>function grupisi(obAR, propOB) {
  return obAR.reduce( (acc, objSab) => {
    let key = objSab[propOB]
    if (!acc[key]) {
      acc[key] = []
    }
    acc[key].push(objSab)
    return acc
  }, {})
}
console.log(grupisi(psi, 'god'))
/* Object {}
1: Array [ {…} ]
10: Array [ {…} ]
40: Array [ {…} ]
60: Array [ {…} ]
200: Array [ {…} ] 
} */
</code>
</pre>
<md>

  * sakupljanje svih nadimaka pasa na jednu gomilu

</md>
<pre>
<code>  
function sviNadimci (obj, prop) {
  return obj.reduce((rez, trenObj) => {
    return [...rez, ...trenObj[prop]]
  }, [])
}

sviNadimci(psi, "nadimci") // [ Beki, Čupi, Pufi, Lizača, Vuki, Vule, Matori, Legenda, Šari, Šarpi, … ]


</code>
</pre>
<md>

## **MAP i FOREACH** 

</md><h3 id="map"><i>map</i></h3><md>

  * map - Slicno kao forEach, samo sto pravi novi Array, a ne menja original
  * otvara se svaki element niza, nesto mu se uradi i pravi se novi niz.
  * callback f-ja moze da ima 3 parametra: vrednost_elementa, index_elementa, pozvani_niz
</md>
<pre>
<code>// npr. [6,5,4].map(v, i, n) // ← neparvilan, jednostavan zapis
//  1. krug: v=6, i=0, n=[6,5,4]
//  2. krug: v=5, i=1, n=[6,5,4]
//  3. krug: v=4, i=2, n=[6,5,4]
// console.log(one2) //! [1,2]
let maped = one2.map(x => x + 10); console.log(maped); //! [11,12]
let maped2 = zxc.map(x => x.toUpperCase()); console.log(maped2); //! [Z,X,C]
// console.log(one2) //! [1,2]
let arrObj = [{ qqq: 1, www: 2, eee: 3 }, { aaa: 4, sss: 5, ddd: 6 }] // [{}, {}]
let maped3 = arrObj.map(x => (x.qqq + x.www) * x.eee); console.log(maped3); //! [9,NaN]
</code>
</pre>
<md>

</md><h3 id="foreach"><i>forEach</i></h3><md>

  * forEach - Izvrsava se callback f-ja nad svakim elementom. Sluzi da bi se nesto uradilo sa elementima iz niza npr. slanje u konzolu ili slanje na HTML stranicu, u neku tabelu. 
    + !!! Radi samo sa Array 
    + !!! Ne moze da radi sa praznim elementima niza (sparse array)
    + !!! Iteracija ne moze da se prekine sa `return`. Eventualno sa `throw Error()`, ali ako su prekidi potrebni onda bolje probati sa: for, for...of, Array.prototype.every (some, find, findIndex).
    + !!! return uvek vraca `undefined`
      - posle forEach-a, nema nadovezivanja lancano, sto je i logicno jer je return `undefined`.
      - Posto je nenadoveziv, najcesce se koristi na kraju lanca da bi izvrsio "side effect". Vidi fajl "Sta je side effect.md"
    + forEach ne menja Array, ali c.b. f-ja moze da ga promeni 
    + `length` niza se snima pre nego sto se pokrene prva iteracija. Prema tome:
      - c.b. f-ja nece koristiti elemente koji su izvan `length`-a koji se snimio na pocetku.
      - ?!ne razumem? Changes to already-visited indexes do not cause callbackFn to be invoked on them again.
      - Ako postoji, jos-neposeceni element niza koji je vec promenjen od cb f-je, njegova vrednost koju prosledjuje ce biti ona koja je bila u vreme prve posete.
      - Obrisani elementi se ne posecuju.
      - !!! Upozorenje: Istovremene modifikacije gore opisane vrste često dovode do teško razumljivog koda i generalno ih treba izbegavati (osim u posebnim slučajevima).
    + Ne mora da ima return (primer 1), osim ako mu ne kazes (primer 2). Sporiji od .map.
    + forEach() ocekuje rad sa SINHRONIM f-jama => izbegavati promis ili async f-ju, forEach nece cekati odgovore.
  * callback f-ja moze da ima 4 parametra: vrednost_elementa, index_elementa, pozvani_niz, thisArg (vrednost koja se koristi kao 'this' argument pri pozivanju f-je)

</md>
<pre>
<code>// Primer 1
zxc = ["z", "x", "c"]
let foreacher = zxc.forEach(x => console.log(x));// undefined - svaki element od "zxc" je bacen u console.log(), a povratna informacija za "foreacher" je nista, undefined.

// Primer 2
one2 = [1, 2]
one2.forEach((num, index) => {
  return one2[index] = num * 2;
});
one2 // [2, 4] - svaki element od "one2" je pomnozen sa 2.

// Primer 2.1 - Sa .map bi to izgledalo ovako:
one2 = one2.map((num, index) => {
  return one2[index] = num * 2;
})
one2 // [2, 4]

// Primer 3
d = {}
arr = 'qwertyuiopasdfghjklzxcvbnm'.split('') // [q, w, e, r, ...]
arr.forEach((q) => {
    d[q] = undefined
})
d // {q:undef., w:undef., e:undef., r:undef., ...}
</code>
</pre>
<md>

</md><h2 id="pakovanje-u-string"><b>PAKOVANJE U STRING</b></h2><md>

</md><h3 id="tostring"><i>toString</i></h3><md>

  * *toString* - ne pretvara u String, nego ga samo prikazuje kao String. 
  * Ako hocu da ga pretvorim, moram taj prikaz da snimim u neku novu promenljivu.

</md>
<pre>
<code>abc; //! [YOY,XxX,A,A,A,YOY,XxX]
abc.toString(); //! YOY,XxX,A,A,A,YOY,XxX
abc; //! [YOY,XxX,A,A,A,YOY,XxX]
</code>
</pre>
<md>

</md><h3 id="join"><i>join</i></h3><md>

  * join - Spaja elemente nizolikog objekta u String.
  * To radi pomocu dopisivanja (konkatenacija).

</md>
<pre>
<code>elements = ['Fire', 'Air', 'Water'];
elements.join() // "Fire,Air,Water"
elements.join('') // "FireAirWater"
elements.join('-') // "Fire-Air-Water"
elements // ne promenjeno - ['Fire', 'Air', 'Water']
</code>
</pre>
<md>

</md><h2 id="array-prototype"><b>ARRAY PROTOTYPE</b></h2><md>

</md><h3 id="array"><i>Array()</i></h3><md>

  * Array "constructor" je metoda koja sluzi za pravljenje novih nizova. Array() u sebi sadrzi jos neke sub-metode. Array, bez zagrada, je Objekat Array, koji u sebi, pod "prototype.constructor" sadrzi metodu Array()

</md>
<pre>
<code>arrayed = Array(2); // [ &lt;2 empty slots> ], length: 2 // &lt;empty slot> nije isto sto i undefined. Vise o tome: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#sparse_arrays
arrayed = Array(2, 3, 'q', []); //! [ 2, 3, 'q', [] ]
arrayed = [2,3,'q',[]] // isto kao gore ali literal
console.log(Array.prototype.constructor==Array) // T
console.log(Array.constructor==Array) // F *ovo je konstruktor za f-ju.
</code>
</pre>
<md>

</md><h3 id="arrayof"><i>Array.of()</i></h3><md>

  * Array.of() - Ako se unosi vise parametara onda je isto kao i "constructor", ali ako se unese samo jedan parametar onda se vidi razlika:

</md>
<pre>
<code>arrayed = Array.of(3); // [ 3 ], normalan niz sa jednim elementom '3', length: 1
arrayed = Array(3); // [ <3 empty slots> ]
</code>
</pre>
<md>

</md><h3 id="arrayfrom"><i>Array.from()</i></h3><md>

  * Array.from() - Pravi niz od necega sto je nizolikog oblika (str, arr, Map, Set) ili od iteratora.
  * Metoda moze da ima 3 parametra: {izvor_od_cega_ce_da_se_pravi_niz}, map_f-ja, thisArg (vrednost koja se koristi kao 'this' argument pri pozivanju map f-je).
  * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from

</md>
<pre>
<code>let nizAZ_2 = Array.from(nizAZ); // Pravljenje novog niza na osnovu postojeceg (kopiranje)
let arrayedFrom = Array.from(5); // prazan niz, length = 5
Array.from(Array(5).keys()) // [0,1,2,3,4] - Array(5).keys() je Array iterator. Od indexa su napravljene vrednosti.
Array.from(Array(5).keys(), a=>++a) // [1,2,3,4,5] - koristeci map f-ju koja ide uz Array.from()
Array.from(Array(6).keys()).slice(1) // [1,2,3,4,5] - moj naziv za ovo je AFAKS (pocetna slova funkcija)
// Array.from(obj, mapFn, thisArg)
// has the same result as Array.from(obj).map(mapFn, thisArg),
// except that it does not create an intermediate array.
</code>
</pre>
<md>

</md><h3 id="arrayisarray"><i>Array.isArray()</i></h3><md>

  * Array.isArray() - proverava da li je niz

</md>
<pre>
<code>let isArrayed = ['e'] + 'Q'; console.log(isArrayed); //! eQ
console.log(Array.isArray(isArrayed)); //! false
</code>
</pre>
<md>

</md>
<pre>
<code>arr = [1,2]
arr['qwe']=4 // dodavanje asocijativnog elementa
arr[Symbol('asd')]=999 // dodavanje simbol elementa
delete Symbol // ne moze biti obrisan, iako prijavljuje "true" tj. da je obrisan.
Array.isArray(arr) // true [1,2] // kad se "otvori" niz onda se vide i ostali elementi (asoc. i sym.)
</code>
</pre>
<md>

</md>
<pre>
  <code>// drugi nacin da se proveri da li je "str" string:
str = 'qwe'
typeof str === "string" // true
</code>
</pre>
<md>

</md><h3 id="arrayentries"><i>Array.entries()</i></h3><md>

  * Array.entries - Vraca iteraciju u obliku [kljuc, vrednost].

</md>
<pre>
  <code>var array1 = ['a', 'b', 'c'];
var iterator1 = array1.entries(); // to sto vraca se zove Array Iterator (a,b,c)
console.log(iterator1.next().value); // Array [0, "a"]
console.log(iterator1.next().value); // Array [1, "b"]
var entriesFromArr = Array.from(iterator1)
console.log(entriesFromArr); //! [[0,"a"], [1,"b"], [2,"c"]]
</code>
</pre>
<md>

</md><h3 id="arraykeys"><i>Array.keys()</i></h3><md>

  * Array.keys - vrace ITERATOR kljuceva (ako je Array onda su to indexi)
</md>
<pre>
  <code>console.log(nizAZ_2); //! [ '.', 1, 2, 3, '?', 'A', 'B', 'C', 'a', 'b', 'c' ]
console.log(Array.from(nizAZ_2.keys())); //! [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
// Kod objekta moze da se koristi za vracanje duzine objekta (posto objekat nema "length" attribut) - Object.keys(qwe).length
</code>
</pre>
<md>

</md><h3 id="manje-bitne-stvari"><i>manje bitne stvari</i></h3><md>

Array.name // "Array" - zamrznuta vrednost  

arr = []  
arr.constructor.name === 'Array' ? 1:0 // 1
Object.isFrozen(arr.constructor.name) // true

// prototype: Array [] // tu se nalaze sve metode vezane za Array ('seckanja', 'razni alati', 'filteri', map, reduce). ?Sto znaci ja kad pozivam neku metodu za Array, ja zapravo pozivam prototip?  
</md>
</body>
</html>
